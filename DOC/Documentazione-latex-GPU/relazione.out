\BOOKMARK [1][-]{section.1}{Algoritmo}{}% 1
\BOOKMARK [2][-]{subsection.1.1}{Introduzione}{section.1}% 2
\BOOKMARK [2][-]{subsection.1.2}{Definizioni}{section.1}% 3
\BOOKMARK [2][-]{subsection.1.3}{Esecuzione di DBSCAN}{section.1}% 4
\BOOKMARK [1][-]{section.2}{Implementazione}{}% 5
\BOOKMARK [2][-]{subsection.2.1}{Introduzione}{section.2}% 6
\BOOKMARK [3][-]{subsubsection.2.1.1}{Dimensione della griglia e dei blocchi - lato host}{subsection.2.1}% 7
\BOOKMARK [2][-]{subsection.2.2}{Implementazione tramite shared memory}{section.2}% 8
\BOOKMARK [3][-]{subsubsection.2.2.1}{Utilizzo della constant memory - lato host}{subsection.2.2}% 9
\BOOKMARK [3][-]{subsubsection.2.2.2}{Utilizzo template metaprogramming - lato host}{subsection.2.2}% 10
\BOOKMARK [3][-]{subsubsection.2.2.3}{Utilizzo della shared memory - lato device}{subsection.2.2}% 11
\BOOKMARK [3][-]{subsubsection.2.2.4}{Calcolo del LBP - lato device}{subsection.2.2}% 12
\BOOKMARK [3][-]{subsubsection.2.2.5}{Conteggio delle transizioni del LBP - lato device}{subsection.2.2}% 13
\BOOKMARK [3][-]{subsubsection.2.2.6}{Controllo uniformit\340 ed incremento istogramma - lato device}{subsection.2.2}% 14
\BOOKMARK [2][-]{subsection.2.3}{Implementazione tramite texture memory}{section.2}% 15
\BOOKMARK [3][-]{subsubsection.2.3.1}{Differenze d'implementazione - lato host}{subsection.2.3}% 16
\BOOKMARK [3][-]{subsubsection.2.3.2}{Differenze d'implementazione - lato device}{subsection.2.3}% 17
\BOOKMARK [2][-]{subsection.2.4}{Differenza di risultati tra implementazione shared memory e texture memory}{section.2}% 18
\BOOKMARK [1][-]{section.3}{Risultati ottenuti}{}% 19
\BOOKMARK [2][-]{subsection.3.1}{Introduzione}{section.3}% 20
\BOOKMARK [2][-]{subsection.3.2}{Capacit\340 di classificazione}{section.3}% 21
\BOOKMARK [2][-]{subsection.3.3}{Tempi d'esecuzione e speedup rispetto alla versione sequenziale}{section.3}% 22
\BOOKMARK [1][-]{section.4}{Istruzioni per compilare ed eseguire il programma}{}% 23
